<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="沐云白">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/03/12/read-effective-c/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="自己习惯C++条款01：把 C++ 看成一个语言联邦C++由几个重要的次语言构成 C语言：区块，语句，预处理器，数组，指针等等。 类：class，封装，继承，多态……（动态绑定等等） 模板：涉及泛型编程，内置数种可供套用的函数或者类。 STL：STL是个模板库，主要涉及容器，算法和迭代器 在不同情况下使用适合的部分，可以使 C++ 实现高效编程 条款02：用const, enum, inline">
<meta property="og:type" content="article">
<meta property="og:title" content="Read Effective C++">
<meta property="og:url" content="http://example.com/2025/03/12/Read-Effective-C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="自己习惯C++条款01：把 C++ 看成一个语言联邦C++由几个重要的次语言构成 C语言：区块，语句，预处理器，数组，指针等等。 类：class，封装，继承，多态……（动态绑定等等） 模板：涉及泛型编程，内置数种可供套用的函数或者类。 STL：STL是个模板库，主要涉及容器，算法和迭代器 在不同情况下使用适合的部分，可以使 C++ 实现高效编程 条款02：用const, enum, inline">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Read-Effective-C.assets/asynccode">
<meta property="og:image" content="https://z1wt6ruhl99.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFjYjkyOWU0MTYxMjhkY2VlYjViOGY4MjMyZWU1MjNfYjhvZ3BXVmk0NEpyQkxZWGVUc3hXbUt3cElHVlhpTm1fVG9rZW46SDVWWGJ0YUVFb3hwTHJ4SmFKTmNUeDlJbk9nXzE3NTIxOTUzNTk6MTc1MjE5ODk1OV9WNA">
<meta property="og:image" content="http://example.com/Read-Effective-C.assets/asynccode">
<meta property="article:published_time" content="2025-03-12T09:55:44.000Z">
<meta property="article:modified_time" content="2025-07-11T00:56:32.543Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Read-Effective-C.assets/asynccode">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            Read Effective C++ | 沐云白的个人主页
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"沐云白的个人主页","subtitle":{"text":["What`s happened`s happened.","Which is an expression of faith in the mechanies of the world.","It`s not an excuse to do nothing."],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.7.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"GITHUB":{"path":"https://github.com/zhangyuxinn","icon":"fa-brands fa-github"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/8/10 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>



<main class="page-container" id="swup">

    

    <div class="main-content-container flex flex-col justify-between min-h-dvh">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                沐云白的个人主页
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   target="_blank" rel="noopener" href="https://github.com/zhangyuxinn"
                                        >
                                    <i class="fa-brands fa-github fa-fw"></i>
                                    GITHUB
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           target="_blank" rel="noopener" href="https://github.com/zhangyuxinn"
                        >
                            <span>
                                GITHUB
                            </span>
                            
                                <i class="fa-brands fa-github fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Read Effective C++</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/redefine-avatar.svg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">沐云白</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-03-12 17:55:44</span>
        <span class="mobile">2025-03-12 17:55:44</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-07-11 08:56:32</span>
            <span class="mobile">2025-07-11 08:56:32</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h1 id="自己习惯C"><a href="#自己习惯C" class="headerlink" title="自己习惯C++"></a>自己习惯C++</h1><h2 id="条款01：把-C-看成一个语言联邦"><a href="#条款01：把-C-看成一个语言联邦" class="headerlink" title="条款01：把 C++ 看成一个语言联邦"></a>条款01：把 C++ 看成一个语言联邦</h2><p>C++由几个重要的次语言构成</p>
<p>C语言：区块，语句，预处理器，数组，指针等等。</p>
<p>类：class，封装，继承，多态……（动态绑定等等）</p>
<p>模板：涉及泛型编程，内置数种可供套用的函数或者类。</p>
<p>STL：STL是个模板库，主要涉及容器，算法和迭代器</p>
<p>在不同情况下使用适合的部分，可以使 C++ 实现高效编程</p>
<h2 id="条款02：用const-enum-inline-替换-define"><a href="#条款02：用const-enum-inline-替换-define" class="headerlink" title="条款02：用const, enum, inline 替换 #define"></a>条款02：用const, enum, inline 替换 #define</h2><p>1、#define 修饰的记号，在<strong>预处理</strong>的时候，已经全部被替换成了某个数值，如果出错，<strong>错误信息可能会提到这个数值，而不会提到这个记号</strong>。在纠错方面很花时间，因为其他程序员不知道这个数值代表什么。我们可以用 const 和 enum 解决这个问题。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum hack 补偿做法：</span></span><br><span class="line"><span class="keyword">enum</span> 枚举量&#123;para1 = value1, para2 = value2,......&#125;</span><br><span class="line"><span class="comment">//将一个枚举类型的数值当作 int 类型使用</span></span><br><span class="line"><span class="comment">//和 #define 很像，都不能取地址，但它没有 #define 的缺点</span></span><br></pre></td></tr></table></figure></div>

<p>2、#define 不能定义类的常量，因为被 #define 定义的常量可以被全局访问，它<strong>不能提供任何封装性</strong>。</p>
<p>3、#define 修饰的宏书写繁琐且容易出错，inline 函数可以避免这种情况：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_COMPARE(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="comment">//这是一个三目运算符，如果 a &gt; b，则返回 a，否则返回 b</span></span><br><span class="line"><span class="comment">//宏中的每一个实参都必须加上小括号</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//调用：</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">MY_COMPARE</span>(++a, b);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">MY_COMPARE</span>(++a, b + <span class="number">10</span>);<span class="comment">//2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1式中，++a =&gt; a = 6 =&gt; 6 &gt; b = 0 =&gt; return ++a;</span></span><br><span class="line"><span class="comment">a 的值竟然增加了两次！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义 inline：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MAX(a, b) (a) &gt; (b) ? (a) : (b)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MY_COMPARE</span><span class="params">(<span class="type">const</span> T&amp;a, <span class="type">const</span> T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        a &gt; b ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//inline 将函数调用变成函数本体</span></span><br><span class="line"><span class="comment">//传入的是 ++a 的值</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MY_COMPARE</span>(++a, b);</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//此时 a = 3 </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">MY_MAX</span>(++a, b);</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//此时 a = 5</span></span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="条款03：尽可能使用-const"><a href="#条款03：尽可能使用-const" class="headerlink" title="条款03：尽可能使用 const"></a>条款03：尽可能使用 const</h2><p>const 允许我们指定一个语义约束，使某个值应该保持不变</p>
<p>1、<strong>const 修饰 变量，指针，函数，函数返回值等，可以使程序减少错误，或者更容易检测错误</strong>：</p>
<p>​        指针常量：int* const p;&#x2F;&#x2F;指针地址不可变，指针指向值可变</p>
<p>​        常量指针：const int* p;<strong>or</strong> int const * p;&#x2F;&#x2F;指针指向值不可变，指针地址可变</p>
<p>​        常量指针常量：const int* const p;&#x2F;&#x2F;都不可变</p>
<p>const 修饰迭代器：</p>
<p>​        iterator 相当于 T* const &#x2F;&#x2F;指针常量</p>
<p>​        const_iterator 相当于 const T* &#x2F;&#x2F;常量指针</p>
<p>const 修饰函数返回值：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> c = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">max</span>(a,b) = c;</span><br><span class="line"><span class="comment">//将 c 的值赋给 max(a, b) 是没有意义的，const 防止这种操作的发生</span></span><br></pre></td></tr></table></figure></div>

<p><strong>2、const 修饰成员函数</strong></p>
<p>​        如果两个成员函数只是常量性不同（其他相同）则可以发生重载</p>
<p>​                const 类对象调用 const 成员函数</p>
<p>​                non-const 类对象调用普通成员函数</p>
<p><strong>bitwise:</strong></p>
<p>​        const 成员函数不能改变（除 static）成员变量的值，因为常函数里 this 指针指向的值不可改变。同理，<strong>const 对象不可以调用 non-const 函数</strong>，因为函数有能力更改成员属性的值。</p>
<p>​        但是若成员变量是一个指针，仅仅改变指针指向的值却不改变指针地址（地址是 this 指向的值），则不算是 const 函数 ，但能够通过 bitwise 测试。</p>
<p>​        <strong>使用 mutable 可以消除 non-static 成员变量的 bitwise constness 约束。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">        &#123;</span><br><span class="line">                m_id = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span>&amp; <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                m_id = <span class="number">888</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">mutable</span> <span class="type">int</span> m_id;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> person <span class="title">p</span><span class="params">(<span class="number">666</span>)</span></span>;</span><br><span class="line">        p.<span class="built_in">func</span>();</span><br><span class="line">        cout &lt;&lt; p.m_id &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3、当 const 和 non-const 成员函数有实质的等价实现时，利用两次转型，令 non-const 调用 const 可以避免代码重复。</strong></p>
<p>用const成员函数实现non-const孪生兄弟的技术。</p>
<p>但是反过来就不行，使用non-const成员函数去实现const会有不必要的风险，<strong>可能会改动曾经承诺过不改动的对象。违背的使用const的理念。</strong></p>
<p><strong>non-const成员函数的功能是包括const成员函数的</strong>，反过来并不是这样。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> name[pos];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;<span class="comment">//移除第一次转型添加的 const</span></span><br><span class="line">            (</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">const</span> classname&gt;(*<span class="keyword">this</span>)[pos]</span><br><span class="line">                <span class="comment">//把 classname 类型数据转换为 const classname</span></span><br><span class="line">                <span class="comment">//使得能够调用 const operator[]</span></span><br><span class="line">            );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="条款04：确定对象被使用前已经被初始化"><a href="#条款04：确定对象被使用前已经被初始化" class="headerlink" title="条款04：确定对象被使用前已经被初始化"></a>条款04：确定对象被使用前已经被初始化</h2><p>有些平台上如果读取未初始化的值会导致程序终止。</p>
<p><strong>1、内置数据类型：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* c = <span class="string">&quot;A C-style string&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>2、自定义数据类型：</strong></p>
<p>确保构造函数将每一个成员初始化。</p>
<p>使用成员初值列替换有参构造，且次序和class声明次序相同：</p>
<p><strong>使用成员初始列进行构造，这样效率更高，成员初始列是初始化，而有参构造是初始化完又进行赋值，相当于白初始化了</strong> </p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>(<span class="type">int</span> age, <span class="type">int</span> id, string name)<span class="comment">//这是一个有参构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这是成员初始列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>(<span class="type">int</span> age, <span class="type">int</span> id, string name):</span><br><span class="line">                <span class="built_in">m_age</span>(age),</span><br><span class="line">                <span class="built_in">m_id</span>(id),</span><br><span class="line">                <span class="built_in">m_name</span>(name)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员初始列格式：</span></span><br><span class="line"><span class="comment">    classname(parameter1, parameter2,...):</span></span><br><span class="line"><span class="comment">    member1(value1),</span></span><br><span class="line"><span class="comment">    member2(value2),</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    membern(value)</span></span><br><span class="line"><span class="comment">    &#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vtruos code style: 别写<span class="comment">/**/</span></span><br></pre></td></tr></table></figure></div>

<p>有参构造是先执行<strong>默认构造</strong>，再给<strong>成员变量赋值</strong>。这有一个坏处，const 修饰的量不可以被赋值，但是可以初始化。</p>
<p>规定成员初值列中，要列出<strong>所有成员变量</strong>，以免忘记。</p>
<p>如果有很多构造函数，可以适当遗漏一些“赋值表现像初始化一样好”的成员变量。</p>
<p>在初值列中，要注意声明顺序，最好是和前面的顺序一样。</p>
<p>成员初始列格式：    classname(parameter1, parameter2,…):    member1(value1),    member2(value2),    …    membern(value)    {}</p>
<p>例如这个，不要变成 2、1、3、。。的样子。</p>
<p>使用成员初值列则省去了默认构造部分。成员初值列在不传参的情况下，可以看成默认构造。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m_size;</span><br><span class="line"><span class="type">char</span> m_array;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这两个成员变量在初始化的时候是有次序的，m_array 的大小是由 m_size 指定的</span></span><br><span class="line"><span class="comment">//所以必须先初始化 m_size</span></span><br><span class="line"><span class="comment">//实际上，成员初值列中变量的次序可以和声明次序不同</span></span><br><span class="line"><span class="comment">//但为防止这类错误出现，成员初值列的次序应当和声明次序相同</span></span><br></pre></td></tr></table></figure></div>

<p><strong>3、使用 local-static 对象替换 non-local-static 对象：</strong></p>
<p>函数内 static 对象是 local-static 对象，函数外 static 对象是 non-local-static 对象。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function">string <span class="title">tname</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> teacher t;</span><br><span class="line"><span class="comment">//声明一个 teacher 对象 t, 预留给用户使用</span></span><br><span class="line"><span class="comment">//不定义是因为我们不知道什么时候用它</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">student</span>(params)</span><br><span class="line">    &#123;</span><br><span class="line">        string a = t.<span class="built_in">tname</span>();</span><br><span class="line">        <span class="comment">//使用 t 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这里就出现问题了，teacher 对象必须在 student 对象之前初始化，但是 student 构造函数中使用的是未初始化的 teacher 对象。</p>
<p>而正常来写，就无法保证teacher一定在student前完成初始化。</p>
<p><strong>解决办法</strong>：利用一个函数，定义并初始化本 static 对象，并返回它的引用。</p>
<p>这个手法的基础在于：c++保证，函数内的<strong>local static</strong>对象会在“该函数调用期间”“<strong>首次遇上该对象之定义式”时被初始化</strong>。所以，用这个方法，就可以保证返回的reference指向一个已经初始化过的对象，就可以防止发生初始化顺序的问题。</p>
<p>是不是很熟悉，这就是单例的实现原理。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function">string <span class="title">pname</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">teacher&amp; <span class="title">teach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> teacher t;<span class="comment">//定义一个 local-static 对象</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">student</span>(params)</span><br><span class="line">    &#123;</span><br><span class="line">        string a = <span class="built_in">t</span>().<span class="built_in">tname</span>();</span><br><span class="line">        <span class="comment">//使用 t() 函数返回的引用，引用期间，teacher对象被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">student&amp; <span class="title">stu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> student s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>extern 声明的对象对于 teacher 而言是一个 non-local-static 对象， teacher&amp; 函数内<strong>声明的对象</strong>对于 teacher 而言是一个 local-static 对象。C++保证，<strong>local-static 对象在包含它的函数被调用期间</strong>（或者说<strong>首次遇到</strong>这个对象），会被初始化。也就是说，如果用<strong>返回引用</strong>的函数访问这个对象，就没有调用未初始化对象的困扰。</p>
<p>但是换个角度看，如果在多线程系统下，这些函数中的static会具有不确定性，任何一种non-const static 对象，在多线程环境下“等待某事发生”都会有麻烦。</p>
<p>解决办法是在程序单线程启动时，手工调用所以reference - returning函数，这样可以一定程度上解决在初始化方面的这个问题。</p>
<h1 id="构造，析构，赋值"><a href="#构造，析构，赋值" class="headerlink" title="构造，析构，赋值"></a>构造，析构，赋值</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><p>在创建类时，如果自己不定义默认构造，拷贝构造（拷贝运算符），析构函数，那么编译器会自动生成这些函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝运算符：</span></span><br><span class="line">classname&amp; <span class="keyword">operator</span>=(<span class="type">const</span> classname&amp; cn)&#123;......&#125;</span><br></pre></td></tr></table></figure></div>

<p>拷贝运算符注意事项：</p>
<p>若成员变量中有引用，或者被 const 修饰等等，拷贝运算符不可被调用。</p>
<p><strong>因为：const 值不可以修改，引用的指向不可以修改。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m_age;</span><br><span class="line">    string&amp; m_name;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;lisa&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;luna&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">p1 = p2;<span class="comment">//error!</span></span><br></pre></td></tr></table></figure></div>

<h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>任何人都应该是天地间独一无二的，很难有理由有两个一毛一样的人。所以对于类中拷贝构造函数，我们应当阻止他们。但若是不声明，编译器也会自动生成拷贝构造函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">person</span>(<span class="type">const</span> person&amp;);</span><br><span class="line">    person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> person&amp;);</span><br><span class="line">    <span class="comment">//参数是不必要写的，毕竟这个函数不会被实现</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>编译器自动生成的函数都是 public 函数，所以我们将 public 改为 <strong>private</strong>，就可以防止对象调用拷贝构造。</p>
<p>注：private <strong>只有member成员函数和friend友元函数可以调用</strong>。</p>
<p>同时也产生了一个问题，如何防止拷贝在成员函数或友元函数中被调用？</p>
<p>答案是建立一个父类，在父类中定义 private 拷贝函数，子类( person 等等)继承父类。因为子类不可以调用父类的 private 函数：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">uncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">uncopyable</span>(<span class="type">const</span> uncopyable&amp;);</span><br><span class="line">    uncopyable <span class="keyword">operator</span>=(<span class="type">const</span> uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;......&#125;;</span><br></pre></td></tr></table></figure></div>

<p>除此之外，这么做还有一个好处，将<strong>连接期错误移至编译期提前产生</strong>，可以提取侦测出错误。</p>
<h2 id="条款07：给多态基类声明-virtual-析构函数"><a href="#条款07：给多态基类声明-virtual-析构函数" class="headerlink" title="条款07：给多态基类声明 virtual 析构函数"></a>条款07：给多态基类声明 virtual 析构函数</h2><p>多态把父类当作一个接口，用以处理子类对象：利用父类指针，指向一个在堆区开辟的子类对象。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>();</span><br><span class="line">    ......</span><br><span class="line">    ~<span class="built_in">person</span>();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>: <span class="keyword">public</span> person&#123;......&#125;;</span><br><span class="line"> </span><br><span class="line">person* p = <span class="keyword">new</span> <span class="built_in">teacher</span>(...); </span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//在堆区开辟的数据要手动删除</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码是有问题的。</p>
<p>我们知道，在普通类继承里，删除子类对象会先调用子类的析构，再调用父类的析构。但在多态里情况有所不同。我们删除的是父类指针，调用的只是父类的析构函数，子类析构不会被调用，也就是说，子类对象没有被删除，而指针却没了。这是局部销毁，会造成资源泄漏等错误。</p>
<p>幸运的是，我们可以通过<strong>虚函数</strong>来解决这个问题。</p>
<p>在多态里，虚函数可以让子类重写父类的函数，同时在虚函数表中生成一个指针，找到子类重写函数的地址，从而让我们可以通过父类访问子类重写的函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">person</span>();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>: <span class="keyword">public</span> person&#123;......&#125;;</span><br><span class="line"> </span><br><span class="line">person* p = <span class="keyword">new</span> <span class="built_in">teacher</span>(...); </span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//删除 p 的时候调用 virtual ~person();</span></span><br><span class="line"><span class="comment">//virtual 找到子类析构函数的地址，导致子类也可以被删除</span></span><br><span class="line">纯虚函数使得父类更像一个接口，这里不用多说。</span><br><span class="line"></span><br><span class="line">注：多态里父类应该至少有一个虚函数(<span class="keyword">virtual</span> 析构)，若不用做多态，则类里不应该有虚函数。</span><br></pre></td></tr></table></figure></div>

<p><strong>不要继承c++的不带virtual析构函数的类，包括所有STL容器，如vector、list、set等。</strong></p>
<p>如果class不是为了多态用途而设计的，就不要用virtual 析构函数。</p>
<h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p>释义：在析构函数内部处理异常</p>
<p>我们来看以下案例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">animal</span>()&#123;...&#125;;</span><br><span class="line">    <span class="comment">//假设执行这个析构函数会抛出一个异常</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt; v;<span class="comment">//假设容器中存储了几个对象</span></span><br><span class="line">    ...</span><br><span class="line">    v.<span class="built_in">clear</span>();<span class="comment">//现在清空容器</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">add</span>();<span class="comment">//摧毁容器之后，剩余的其他操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>由于对象属于 person 类，在删除的时候会调用析构函数，而 person  的析构函数会抛出一个异常，且未进行异常处理，所以异常会到 test 函数里。 v 中存储了不止一个对象，所以会同时抛出多个异常到test函数里。</p>
<p>在C++程序中，若是同时存在两个异常，则要么结束程序，要么导致不确定行为。结束程序，剩余的操作就无法完成，这对于程序员来说是一个麻烦。</p>
<p>首先介绍一下异常处理的办法：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"><span class="comment">//try 内部写可能产生异常的语句，没有产生异常，则catch语句不执行，产生则一一匹配</span></span><br><span class="line"><span class="comment">//catch 用于捕获并处理异常，和 case 有异曲同工之妙</span></span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>、可以使用 <span class="built_in">abort</span>(); 函数终止程序</span><br><span class="line">    <span class="number">2</span>、可以吞下这个异常，在 <span class="keyword">catch</span> 内部做一些处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> 了解如何处理异常之后，我们就可以实现如条款所说，在<strong>析构函数内部处理异常</strong>：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">employee</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">furlough</span><span class="params">()</span></span>; <span class="comment">//这是一个放假函数，不放假则抛出一个异常</span></span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">manager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">manager</span>()</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            ep.<span class="built_in">furlough</span>();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//用于确保工人在劳碌后总是可以放假</span></span><br><span class="line">        <span class="built_in">catch</span>(...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//内部实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    employee ep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>但我们对此还有一个想法：</p>
<p>假设员工对不让放假的处理是抗议，如果员工很在意这份工作且不想007，显然，在辞职的情况下抗议是没有意义的，因为他们已经失去了这份工作了。所以他们需要在失去工作之前，对不让放假进行处理。</p>
<p>也就是说，我们需要对函数运行期间抛出的异常做出反应，以防止影响到后面的操作。对此我们可以在类里添加一个普通函数：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">manager</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">holiday</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ep.<span class="built_in">furlough</span>();<span class="comment">//如果没有抛出异常，则析构中 if 不会执行</span></span><br><span class="line">        <span class="comment">//如果抛出异常，则异常回滚到上级函数中</span></span><br><span class="line">        <span class="comment">//我们在上级函数中，holiday 函数之后可以定义一个 try catch 语句对异常进行处理</span></span><br><span class="line">        fangjia = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">     ~<span class="built_in">manager</span>()<span class="comment">//析构函数处理异常作为二重保证</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(!fangjia)<span class="comment">// if fangjia == false</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                ep.<span class="built_in">furlough</span>();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//用于确保工人在劳碌后总是可以放假</span></span><br><span class="line">            <span class="built_in">catch</span>(...)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//内部实现</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    employee ep;</span><br><span class="line">    <span class="type">bool</span> fangjia;<span class="comment">//bool 的默认值依赖编译器，前文有提到过，一定要初始化。令 fangjia = false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这部分也就是说，给客户多一个选择，让其可以在第一时间处理这个问题。</p>
<h2 id="条款09：绝不在构造和析构函数中使用虚函数"><a href="#条款09：绝不在构造和析构函数中使用虚函数" class="headerlink" title="条款09：绝不在构造和析构函数中使用虚函数"></a>条款09：绝不在构造和析构函数中使用虚函数</h2><p><strong>众所周知，在类的操作中，父类比子类先构造，而子类也比父类先析构（多态也是如此，多态先通过 virtual 找到子类析构，再析构父类），所以在构造父类的时候，子类对象还未进行初始化，在析构父类的时候，子类已经被销毁。</strong></p>
<p>此时，如果父类的构造和析构函数中有 virtual ,则该函数无法找到子类的地址（或者说无视子类，因为子类被销毁&#x2F;未被初始化），使程序发生不明确的行为。</p>
<p><strong>解决办法：</strong></p>
<p>virtual 函数的调用无法下降至子类，但是子类可以将必要的构造信息向上传递到父类：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">teacher</span><span class="params">(<span class="type">int</span> score)</span></span>;<span class="comment">//父类的构造</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">score_record</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; score)</span> <span class="type">const</span></span>;<span class="comment">//non-virtual 函数</span></span><br><span class="line">        ......</span><br><span class="line">&#125;; </span><br><span class="line">teacher::<span class="built_in">teacher</span>(<span class="type">const</span> <span class="type">int</span>&amp; score)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="built_in">score_record</span>(score);<span class="comment">//构造执行记录分数的操作</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>: <span class="keyword">public</span> teacher&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">student</span>(pare):<span class="built_in">teacher</span>(<span class="built_in">get_score</span>(para))<span class="comment">//将信息传入父类的构造函数，使其记录一个分数</span></span><br><span class="line">        &#123;......&#125;</span><br><span class="line">        ......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_score</span><span class="params">(para)</span></span>;<span class="comment">//利用一个 static 函数传递分数的值，static 不会传入未初始化的变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>传递给父类的内容，取决于如何设计在构造函数中要达成的效果，也就是子类于父类特殊的地方，传递特殊处即可。</p>
<p><strong>值得注意的是，获取传递参数的这个函数，需要是static，static函数不好传入未初始化的变量。</strong></p>
<h2 id="条款10：令-operator-返回一个-reference-to-this"><a href="#条款10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款10：令 operator&#x3D; 返回一个 reference to *this"></a>条款10：令 operator&#x3D; 返回一个 reference to *this</h2><p>释义：让赋值运算符重载版本返回一个自身 （<strong>reference to *this</strong>），以便实现链式编程。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">employee</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> m_salary;</span><br><span class="line">        <span class="built_in">employee</span>(<span class="type">int</span> a)<span class="comment">//有参构造，赋工资初值</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_salary = a;</span><br><span class="line">        &#125;</span><br><span class="line">        employee&amp; <span class="keyword">operator</span>=(<span class="type">const</span> employee&amp; ep)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;m_salary = ep.m_salary;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//返回其本身</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="function">employee <span class="title">e1</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">        <span class="function">employee <span class="title">e2</span><span class="params">(<span class="number">50000</span>)</span></span>;</span><br><span class="line">        <span class="function">employee <span class="title">e3</span><span class="params">(<span class="number">123456</span>)</span></span>;</span><br><span class="line">        e1 = e2 = e3;</span><br><span class="line">    <span class="comment">//链式编程</span></span><br></pre></td></tr></table></figure></div>

<h2 id="条款11：在-operator-中处理自我赋值"><a href="#条款11：在-operator-中处理自我赋值" class="headerlink" title="条款11：在 operator&#x3D; 中处理自我赋值"></a>条款11：在 operator&#x3D; 中处理自我赋值</h2><p>我们来看一段代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;...&#125;;</span><br><span class="line">person p;</span><br><span class="line">p = p;</span><br></pre></td></tr></table></figure></div>

<p>这是自我赋值，这种操作看起来有点愚蠢，但是并不很难发生。</p>
<p>比如，一个对象可以有很多种别名，客户不经意间让这些别名相等；</p>
<p>或者如之前所说，父类的指针&#x2F;引用指向子类的对象，也会造成一些自我赋值的问题。</p>
<p>自我赋值往往没有什么意义，还会有不安全性。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    student* s;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">teacher&amp; teacher::<span class="keyword">operator</span>=(<span class="type">const</span> teacher&amp; teach)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">        s = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="keyword">new</span> <span class="built_in">student</span>(*teach.s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//便于链式操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码是不安全的。如果 *this 和 teach 是同一个对象，那么客户在删除 *this 的时候，也把 teach 删除了，s 就会指向<strong>一个被删除的对象</strong>。这是不允许的。</p>
<p>我们提供三种方法以解决这个问题：</p>
<p><strong>1、证同检测：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">teacher&amp; teacher::<span class="keyword">operator</span>=(<span class="type">const</span> teacher&amp; teach)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;teach)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//证同检测</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">        s = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="keyword">new</span> <span class="built_in">student</span>(*teach.s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//便于链式操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>遗憾的是，证同检测可以保证<strong>自我赋值</strong>的安全性，但是不能保证“<strong>异常安全性</strong>”。即，如果 new student 抛出异常，则 s 就会指向一个<strong>被删除的对象</strong>，这是一个有害指针，我们无法删除，甚至无法安全读取它。</p>
<p><strong>2、记住原指针：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">teacher&amp; teacher::<span class="keyword">operator</span>=(<span class="type">const</span> teacher&amp; teach)</span><br><span class="line">&#123;</span><br><span class="line">    student* stu = s;            <span class="comment">//记住原指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">        s = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="keyword">new</span> <span class="built_in">student</span>(*teach.s);   <span class="comment">//如果抛出异常，s 也可以找回原来地址</span></span><br><span class="line">    <span class="keyword">delete</span> stu;                  <span class="comment">//删除指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//便于链式操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是精心周到的语句顺序，在保证不发生异常后，在删除指针。</p>
<p><strong>3、copy and swap:</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> teacher&amp; teach)</span></span></span><br><span class="line"><span class="function"></span>&#123;......&#125;</span><br><span class="line"> </span><br><span class="line">teacher&amp; teacher::<span class="keyword">operator</span>=(<span class="type">const</span> teacher&amp; teach)</span><br><span class="line">&#123;</span><br><span class="line">    teacher <span class="built_in">temp</span>(teach);    <span class="comment">//拷贝一个副本</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);             <span class="comment">//将副本和 *this 交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//便于链式操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>交换操作不要考虑原本指针内容，可以保证赋值安全性，同时也能保证异常安全性。</p>
<h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><p>释义：自定义拷贝函数时，要把类变量写全（子类拷贝不要遗漏父类的变量）。</p>
<p>在编写copying函数时，请确保：</p>
<p>①复制所有local成员变量。</p>
<p>②调用所有base classes内的适当的copying函数。</p>
<p>父类变量通常存储在 private 里，子类不能访问父类 private 对象，所以应该<strong>调用父类的构造函数</strong>：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">animal</span>(<span class="type">const</span> animal&amp; an)</span><br><span class="line">    &#123;......&#125;</span><br><span class="line">    animal&amp; opeartor=(<span class="type">const</span> animal&amp; an)</span><br><span class="line">    &#123;......&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string <span class="keyword">typename</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>: <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cat</span>(<span class="type">const</span> cat&amp; c);</span><br><span class="line">    cat&amp; <span class="keyword">operator</span>=(<span class="type">const</span> cat&amp; c);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string cat_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">cat::<span class="built_in">cat</span>(<span class="type">const</span> cat&amp; c)</span><br><span class="line">    :<span class="built_in">cat_type</span>(c.cat_type),</span><br><span class="line">    <span class="comment">//为了不遗漏父类变量，调用父类函数</span></span><br><span class="line">    <span class="built_in">animal</span>(c)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line">cat::cat&amp; <span class="keyword">operator</span>=(<span class="type">const</span> cat&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为了不遗漏父类变量，调用父类函数</span></span><br><span class="line">    animal::<span class="keyword">operator</span>=(c);</span><br><span class="line">    <span class="keyword">this</span>-&gt;cat_type = c.cat_type;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>值得注意的是，上面代码 copy函数和 “&#x3D;”运算符调用的都是和本身一样的函数。究其原因，copy函数是创建一个新的对象，operator&#x3D; 是对已经初始化的对象进行操作。</p>
<p>我们不能用 copy调用operator&#x3D;, 这相当于用构造函数初始化一个新对象（尚未构造好）</p>
<p>同理，也不能用 operator&#x3D; 调用 copy, 这相当于构造一个已经存在的对象（父类已经存在了）</p>
<p>如果operator&#x3D;和copy函数有很多相同的部分，正确做法应该是搞一个新的第三者函数，然后operator&#x3D; 和copy函数调用这个新的函数。</p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><p><strong>所谓资源，就是不再使用它时，将其还给系统。</strong></p>
<p>周所周知，堆区开辟的数据需要程序员手动释放，否则会在程序结束的时候由系统释放。在此前提下，我们来看一段代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">employee</span>&#123;...&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    employee* emp = <span class="keyword">new</span> <span class="built_in">employee</span>();<span class="comment">//动态分配一个对象</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> emp;<span class="comment">//手动释放，否则emp跑出 func() 函数,造成资源泄露</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以预见，如果在 delete 之前，执行了诸如 return, 抛出异常等等，会导致程序跳过 delete ,使 emp 在堆区开辟的对象未被手动释放，造成资源泄露。（删除的是指针，指针指向的数据没有被删除。）</p>
<p><strong>因为在子函数结束时，其中的类对象会发生析构，所以，我们可以利用这个“析构函数自动调用机制”特性，建立一个类，来自动管理资源。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;T&gt; 就是这个效果，是一个类指针对象，智能指针。 </span><br></pre></td></tr></table></figure></div>

<p>示范了“以对象管理资源”的两个关键想法：</p>
<ol>
<li>获得资源后，立刻放进管理对象内。</li>
</ol>
<p>“资源取得的实际便是初始化的时机”，因为我们总是在获得一笔资源后，于同一语句内，初始化某个管理对象。</p>
<ol>
<li>管理对象运营析构函数确保资源被释放。</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">employee</span>&#123;...&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">manager</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    employee* empPrt;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">manager</span>(employee* emp):</span><br><span class="line">        <span class="built_in">empPrt</span>(emp)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">manager</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">delete</span> empPrt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">employee* <span class="title">createmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;<span class="comment">//在堆区创建一个对象</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">manager <span class="title">m</span><span class="params">(createmp())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了预防多个auto_ptr指向同一个对象，一个销毁该对象后其他智能指针指向未知的问题，</p>
<p><strong>auto_ptr有个性质：如果复制他们，会变成null，而复制所得的指针获得资源的唯一拥有权。</strong></p>
<p>但是这些智能指针的析构函数内都是 delete 而不是delete[]，所以智能指针储存数组之类的对象的时候要小心。</p>
<p>利用 manager 资源管理类创建员工对象，在 func 函数结束的时候，manager析构释放了员工对象总结：建立资源管理类—&gt;管理类存储资源的地址变量—&gt;管理类的构造函数为变量初始化，析构函数手动释放变量在堆区开辟的内存。</p>
<h2 id="条款14：在资源管理类中小心-copying-行为"><a href="#条款14：在资源管理类中小心-copying-行为" class="headerlink" title="条款14：在资源管理类中小心 copying 行为"></a>条款14：在资源管理类中小心 copying 行为</h2><p>有的时候，对于资源管理类的 copy 是不必要的，比如管理员工类，每个员工都是单独的个体。但在另一些情况下，copy 也是被程序员需要的。</p>
<p><strong>我们对资源管理类中的 copy 有三种常用的处理方式：</strong></p>
<p><strong>1、禁止 copy 行为：当我们不想某个对象被复制时</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">manager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//将copy和operator=设为私有</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>2、深拷贝：当我们想要多个这个对象的复件时</strong></p>
<p>所谓深拷贝就是在堆区重新开辟一个地址，存储和这个对象相同的数据</p>
<p>（相信同学们都熟练掌握了深拷贝）</p>
<p><strong>3、深拷贝之后删除原件：当我们只想要一个这个对象时</strong></p>
<p>这个是auto_ptr的复制方法。</p>
<p>补充一点：引用计数法：</p>
<p><strong>shared_ptr</strong></p>
<p>创建一个对象时，其引用数+1，这个对象指向一个新的对象时，其引用数-1，被指向对象引用数+1，当引用数为 0 的时候，delete 这个对象。</p>
<h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><p><strong>管理类存放的是资源的指针，我们无法从管理类直接得到一个资源对象（只能得到一个指针，通过指针找到对象）。所以我们最好用显式转化或者隐式转换（自动类型转换）来得到一个资源对象：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">employee</span>&#123;...&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">manager</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    employee* e;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">employee <span class="title">get</span><span class="params">()</span> <span class="type">const</span>        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> *e;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//这是显示转化</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">employee</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *e;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">manager <span class="title">m</span><span class="params">(...)</span></span>;</span><br><span class="line">employee emp = m.<span class="built_in">get</span>();<span class="comment">//调用显式</span></span><br><span class="line"> </span><br><span class="line">employee m1 = m;</span><br><span class="line"><span class="comment">//隐式，manager 对象转换成了 employee 对象 </span></span><br></pre></td></tr></table></figure></div>

<h2 id="条款16：成对使用-new-和-delete-时要采取相同形式"><a href="#条款16：成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="条款16：成对使用 new 和 delete 时要采取相同形式"></a>条款16：成对使用 new 和 delete 时要采取相同形式</h2><p>众所周知，数组名表示数组第一个地址</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string* s = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">delete</span> s;</span><br></pre></td></tr></table></figure></div>

<p>所以执行 delete 时，删除的只是第一个对象，后面19个往往不大可能被删除。</p>
<p>对堆区数组的释放可以使用以下方式：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string* s = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">delete</span>[] s;</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<p>new &lt;&#x3D;&gt; delete</p>
<p>new [] &lt;&#x3D;&gt; delete[]</p>
<h2 id="条款17：以独立语句将-newed-对象置入智能指针"><a href="#条款17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款17：以独立语句将 newed 对象置入智能指针"></a>条款17：以独立语句将 newed 对象置入智能指针</h2><p>首先介绍一下什么是智能指针：</p>
<p>C++提供智能指针来方便客户对资源进行管理，相当于一个资源管理类。常见的智能指针有：</p>
<p>tr1::shared_ptr&lt;&gt;</p>
<p>auto_ptr&lt;&gt;</p>
<p>它是一个格式像容器的变量类型：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例：</span></span><br><span class="line"><span class="function">tr1::shared_ptr&lt;employee&gt; <span class="title">m</span><span class="params">(createmp())</span></span>;</span><br><span class="line"><span class="function">manager <span class="title">m</span><span class="params">(createmp())</span></span>;</span><br><span class="line"><span class="comment">//这两个效果差不多</span></span><br><span class="line"><span class="comment">//manager 是自定义的一个资源管理类</span></span><br></pre></td></tr></table></figure></div>

<p>以上两个智能指针的主要区别在于 copy 行为上：</p>
<p> tr1::shared_ptr&lt;&gt;在拷贝上允许深拷贝</p>
<p>auto_ptr&lt;&gt;在拷贝上允许拷贝之后删除原件</p>
<p>我们来看一段代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//这是一个普通的函数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个函数，调用智能指针</span></span><br><span class="line"><span class="built_in">useemployee</span>(tr1::<span class="built_in">shared_ptr</span>&lt;employee&gt; (<span class="keyword">new</span> employee), <span class="built_in">func</span>());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//tr1::shared_ptr&lt;employee&gt; (new employee)语句的执行顺序：</span></span><br><span class="line"><span class="comment">//先执行 new employee</span></span><br><span class="line"><span class="comment">//再将 new 的地址存放到 shared_ptr 中</span></span><br></pre></td></tr></table></figure></div>

<p>C++对于函数参数的运算顺序有很大的弹性，在其他语言中，是先执行tr1::shared_ptr<employee> (new employee)，再执行 func()。</employee></p>
<p>但 C++ 不是，func() 函数可能插在 tr1::shared_ptr<employee> (new employee) 中：</employee></p>
<p>&#x2F;&#x2F;其他语言</p>
<p>new employee</p>
<p>tr1::shared_ptr</p>
<p>func()</p>
<p>&#x2F;&#x2F;C++</p>
<p>new employee</p>
<p>func()</p>
<p>tr1::shared_ptr</p>
<p>这时候，如果 func() 抛出异常之类，则 new 的地址就无法置入 shared_ptr 中，造成资源泄露。</p>
<p><strong>所以，我们需要一条独立语句将 new 置入 tr1::shared_ptr 中：</strong></p>
<p>tr1::shared_ptr<employee> emp(new employee);&#x2F;&#x2F;独立语句存放地址</employee></p>
<p>useemployee(emp, func());&#x2F;&#x2F;调用</p>
<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><p><strong>1、保证参数一致性：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;......&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print_date</span>(<span class="number">2022</span>, <span class="number">28</span>, <span class="number">9</span>);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">print_date</span>(<span class="number">2022</span>, <span class="number">9</span>, <span class="number">28</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></div>

<p>在这样一个打印时间的函数接口中，我们按照年月日的顺序输出，但是1式却输出年日月。错误的参数传递顺序造成了接口的误用。</p>
<p><strong>解决办法：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">day</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">month</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">year</span>&#123;...&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(<span class="type">const</span> year&amp; y, <span class="type">const</span> month&amp; m, <span class="type">const</span> day&amp; d)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然，传递某个有返回值的函数也是可以解决的，但这种方法看起来很奇怪。</p>
<p><strong>2、保证接口行为一致性：</strong></p>
<p>内置数据类型（ints， double…）可以进行加减乘除的操作，STL中不同容器也有相同函数（比如size，都是返回其有多少对象），所以，尽量保证用户自定义接口的行为一致性。</p>
<p>并且尽量和内置数据类型的接口保持一致、保持兼容。</p>
<p><strong>3、如果一个接口必须有什么操作，那么在它外面套一个新类型或者限制类型上的操作，束缚对象值，：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">employee* <span class="title">createmp</span><span class="params">()</span></span>;<span class="comment">//其创建的堆对象要求用户必须删除</span></span><br></pre></td></tr></table></figure></div>

<p>如果用户忘记使用资源管理类，就有错误使用这个接口的可能，所以必须先<strong>下手为强</strong>，直接将 createmp() 返回一个资源管理对象，比如智能指针share_ptr 等等：</p>
<p>tr1::share_ptr<employee> createmp();</employee></p>
<p>如此就避免了误用的可能性。</p>
<p><strong>4、有些接口可以定制删除器，就像 STL 容器可以自定义排序，比较函数一样</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">p</span><span class="params">(<span class="number">0</span>, my_delete())</span></span>;<span class="comment">//error! 0 不是指针</span></span><br><span class="line"> </span><br><span class="line"><span class="function">tr1::share_ptr&lt;employee&gt; <span class="title">p</span><span class="params">(<span class="keyword">static_cast</span>&lt;employee*&gt;(<span class="number">0</span>), my_delete())</span></span>;<span class="comment">//定义一个 null 指针</span></span><br></pre></td></tr></table></figure></div>

<p>第一个参数是被管理的指针，第二个是自定义删除器。</p>
<p>这个也可以防范DLL问题，用来自动解除互斥锁。（见条款14）</p>
<p>总而言之，就是把客户当成傻逼，要规避他们可能犯的绝大部分错误。</p>
<h2 id="条款19：设计-class-犹如设计-type"><a href="#条款19：设计-class-犹如设计-type" class="headerlink" title="条款19：设计 class 犹如设计 type"></a>条款19：设计 class 犹如设计 type</h2><p>对于每一个 class 都要精心设计，要考虑其构造析构函数，初始化和赋值，继承，类型转换，运算符重载，值传递等问题。</p>
<ol>
<li>新type的对象应该如何创建和销毁？</li>
<li>对象的初始化和对象的赋值有什么样的差别？见条款04 ，个人感觉主要是 处理const的时候比较关键，初始化是在对象创建时，赋值时创建之后。</li>
<li>新type的对象如果被passed by value ，意味着什么？copy构造函数用来定义一个type的passed by value该如何实现。TODO::没懂。</li>
<li>什么是新type的合法值？ 主要涉及到class必须维护的约束条件，也就是成员函数需要进行的检查工作。</li>
<li>如果新type需要继承，检查函数的virtual情况。</li>
<li>你的新type需要什么样的转换？TODO::没大理解。</li>
<li>什么样的操作符和函数对此type是合理的？ 决定需要声明那些函数，其中那些该是member函数。（条款23，24，46）</li>
<li>什么样的标准函数需要驳回？ 也就是你需要声明为private的函数。</li>
<li>谁该取用新type的成员？也就是考虑哪些成员应该是public&#x2F;protected&#x2F;private。</li>
<li>什么是新type的“未声明接口”？ 它对效率、异常安全性（见条款29）以及资源运用（如多任务锁定和动态内存）提供什么保证？在这方面提供的保证将为你的class实现代码加上相应的约束条件。TODO::没大懂。</li>
<li>你的新type有多么一般化？ 如果你是在定义一整个types家族，应该定义一个新的class template。</li>
<li>你真的需要一个新type吗？</li>
</ol>
<h2 id="条款20：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</h2><p>释义：用 const引用传递替换值传递</p>
<p>值传递是新创建一个对象，将这个对象和原对象相等，如果用在类里面，当类中成员变量数目较少的时候，也许问题不大（在类里值传递先调用构造，再调用析构）。但当类中成员变量数目过大时，每一次值传递就会造成时间浪费。 <strong>如果看到这里随便找个例子（找有继承的）算一下调用值传递函数的成本。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createStudent（student s）；</span><br><span class="line">student继承person，调用该函数，要先调用student的构造函数，然后再调用person的构造函数，析构时也是。</span><br></pre></td></tr></table></figure></div>

<p>引用传递是生成一个别名指向这个地址，其本身是个指针，无论原对象有多少个成员变量，都能在一瞬间找到某一个。用上const令其成为常量指针，即“只读”，防止函数修改传入的引用。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> m_n;<span class="comment">//有 n 个变量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1_num</span><span class="params">(Number num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1_num</span><span class="params">(<span class="type">const</span> Number&amp; num)</span></span>;</span><br><span class="line"> </span><br><span class="line">Number num1;</span><br><span class="line"><span class="built_in">print1_num</span>(num1);<span class="comment">//构造，析构一个Number对象</span></span><br><span class="line"><span class="built_in">print2_num</span>(num1);<span class="comment">//传地址</span></span><br></pre></td></tr></table></figure></div>

<p>此外，值传递在类里还有一个问题：容易造成切割问题。</p>
<p>比如一个子类继承父类，传递子类对象的时候，可能只创建了一个父类的对象，子类部分缺失了：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base_class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived_class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_class</span><span class="params">(base_class b)</span></span>;<span class="comment">//这是一个打印函数</span></span><br><span class="line"> </span><br><span class="line">derived_class d;</span><br><span class="line"><span class="built_in">print_class</span>(d);</span><br></pre></td></tr></table></figure></div>

<p>当我们把 d 传入后，参数 b 被<strong>构造</strong>成了一个父类对象，所以子类的特化信息都会被切除，调用 virtual 函数的时候不会调用子类函数。但我们传入的是子类对象。</p>
<p><strong>如果你使用的时内置类型（如int）或者STL容器，使用pass by value也是可以的，因为他们是这么被设计的。“规则的改变取决于你使用那一部分的c++”（条例01）。</strong></p>
<p><strong>除了这些其他最好都遵循这个原则。</strong></p>
<p>但是对象小并不意味着copy函数不昂贵，许多对象内涵的东西就比一个指针多一点，但是复制这种对象却要承担“复制哪些指针所指的每一样东西”，这十分昂贵。TODO::没懂。</p>
<h2 id="条款21：必须返回对象时，别妄想返回其-reference"><a href="#条款21：必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其 reference"></a>条款21：必须返回对象时，别妄想返回其 reference</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">number</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">number</span>(<span class="type">int</span> a);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> number <span class="keyword">operator</span>+(<span class="type">const</span> number&amp; n1, <span class="type">const</span> number&amp; n2);    <span class="comment">//创建一个新对象，返回它</span></span><br><span class="line">    <span class="comment">//const number&amp; operator+(const number&amp; n1, const number&amp; n2);</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">number <span class="title">n1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//n1 = 1</span></span><br><span class="line"><span class="function">number <span class="title">n2</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//n2 = 2</span></span><br><span class="line"> </span><br><span class="line">number n3 = n1 + n2;</span><br></pre></td></tr></table></figure></div>

<p>周所周知，return 返回的是一个浅拷贝副本，返回一个对象是没有问题的，但如果返回一个引用，原对象被销毁之后，引用的指向也被销毁了，也就是引用指空，出错。</p>
<p>此后我们想解决引用指空的问题，就需要创建对象，途径有2，在stack或者heap中创建，如果定义一个local变量，也就是在stack空间中创建：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> number&amp; <span class="keyword">operator</span>+(...)&#123;</span><br><span class="line">     number result;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是一个很糟糕的代码，因为这个stack在函数结束后就<strong>已经被销毁</strong>，调用者对次返回值做一点运用，就会陷入“无定义行为”。</p>
<p>我们当然可以用 new 解决这个问题，但是当变量数目多的时候，程序员往往不知道怎么使用 delete:</p>
<p>n3 &#x3D; n1 + n2 + n4 + …</p>
<p><strong>这一定会发生内存泄漏。</strong></p>
<p>或许有人想到创建一个 static 对象，但这也是有问题的，我们每次调用都是对同一个 static 操作：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> number&amp; <span class="keyword">operator</span>+(...)&#123;</span><br><span class="line">    <span class="type">static</span> number result;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> number&amp; n1, <span class="type">const</span> number&amp; n2);</span><br><span class="line">number n1, n2, n3, n4;</span><br><span class="line">(n1 + n2) == (n3 + n4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>

<p>上述对result 进行了两次操作，第一次 n1+n2, 第二次 n3+n4 </p>
<p>注：这不同于链式编程，在上述中，我们并不想改变 n1 或者 n2 的值，否则我们直接返回 n1 或者 n2 的引用就可以了。</p>
<p>总结：虽然返回一个对象需要构造，析构等操作而产生一些代价，但是如果我们不想改变已有的值，就最好不要返回一个引用，而是支付这些代价。（这在时间上会多一点，但创建的对象会随运算符的结束而被销毁。这比“未定义行为（返回一个新建对象的引用）”，“资源泄漏”，“结果出错”要好得多了。）</p>
<p>正常返回就行，不要出现<strong>返回一个pointer或者reference指向一个local stack中的对象</strong>等问题。</p>
<h2 id="条款22：将成员变量声明为-private"><a href="#条款22：将成员变量声明为-private" class="headerlink" title="条款22：将成员变量声明为 private"></a>条款22：将成员变量声明为 private</h2><p>public:所有都能访问</p>
<p>protected:类对象不可以访问</p>
<p>private:只有类成员函数可以访问</p>
<p>private 优点：</p>
<p>1、使成员变量的控制更为精准：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setage</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setid</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p> 用户通过某一函数控制一个私有变量，防止被误用，同时可以为“<strong>所有可能的实现</strong>”提供弹性，例如，可以实现成员变量被读时轻松通知其他对象、验证class的约束条件、验证函数的前提和事后状态、多线程中实现同步控制等。。</p>
<p>2、使类更有封装性：</p>
<p>让我们看看不封装是什么后果：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person p;<span class="comment">//创建一个 person 对象</span></span><br><span class="line">    p.m_id;<span class="comment">//调用其中一个变量</span></span><br><span class="line">    <span class="built_in">func2</span>();<span class="comment">//这个函数也调用了 p.m_id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>乍一看好像没什么，但如果 func2() 嵌套一个和自己同类型的函数呢？（可以看成递归）</p>
<p>那么 p.m_id 就被无限调用，当代码出错想要修改的时候，想想你的头发，那真是一个灾难。</p>
<p>而封装起来，修改只要改一小部分代码就可以了。</p>
<p><strong>并且在封装后，可以为你修改实现提供可能，如果不封装，你要修改你的实现就需要修改客户的代码，很复杂。</strong></p>
<p>protected不比private有封装性，因为protected子类也可以实现上述代码的操作。</p>
<h2 id="条款23：宁以-non-member-non-friend-替换-member-函数"><a href="#条款23：宁以-non-member-non-friend-替换-member-函数" class="headerlink" title="条款23：宁以 non-member, non-friend 替换 member 函数"></a>条款23：宁以 non-member, non-friend 替换 member 函数</h2><p>释义：如果一个成员函数调用了其他的成员函数，那么就要用一个非成员函数替换这个成员函数。</p>
<p>为什么要封装：</p>
<p>愈多东西被封装，就愈少人可以看到他，愈少人看到他，就有更大的弹性去变化他，因为我们改变的仅仅直接影响到看到改变的那些事物。因此，封装的越多，我们改变那些东西的能力就越大。</p>
<p>也就是说，能使我们改变的事物只影响到更有限的客户。</p>
<p>如何测量封装性：</p>
<p>一种比较粗糙的办法是：计算能够访问该数据的函数数量。</p>
<p>根据条款22，对类变量的操作只能通过类成员函数实现（因为它是私有变量），那么如果一个成员函数内部实现是<strong>调用其他的成员函数</strong>，则<strong>一个非成员函数</strong>也可以做到这样的效果：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">preson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_all</span><span class="params">(<span class="type">const</span> person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">func1</span>();</span><br><span class="line">    p.<span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> func3() 和 use_all() 的效果是一样的，但这时候我们倾向于选择 use_all 函数，因为func3()作为一个成员函数，其<strong>本身也是个可以访问私有变量的函数</strong>。use_all() 函数其本身<strong>不可以访问私有变量</strong>。所以 use_all() 比 func3() 更有封装性。（<strong>能够访问私有变量的函数越少，封装性越好</strong>）</p>
<p>在了解这点之后，我们做一些更深层次的探讨：</p>
<p>我们称 use_func()（func3()的<strong>非成员函数版本</strong>）为便利函数。假设一个类有多个诸如 func1() 的函数，根据排列组合，也就有很多便利函数。</p>
<p>我们可以设计一个工具类，将这些use_func()都放到里面写成static member函数。</p>
<p>但是在c++中，我们一般把便利函数和类放在一个 namespace 中，要知道，namespace和class不同，前者可以跨越多个源码文件，而class不行。</p>
<p>而一个这样的大类，比如说是控制web的大类，其中有很多便利函数，可能某些与bookmarks相关，有些与打印相关，有些与cookie的管理相关，但是大部分客户只对其中一部分感兴趣，就没必要与其他部分的便利函数发生<strong>编译相依关系。</strong>分离他们最好的办法就是将各个部分声明在自己的分类的头文件中，比如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件 &quot;webbrowser.h&quot;</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span>&#123;....&#125;;<span class="comment">//核心类，存放几乎所有客户都需要用到的non-member函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&quot;webbrowserbookmarks.h&quot;</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与书签相关的便利函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&quot;webbrowsercookies.h&quot;</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与cookie相关的便利函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这正是C++标准库的写法，其中有数十个头文件<vector>,<memory>…等，客户只引用他需要的那个部分，这样就不会与其他部分形成编译相依。</memory></vector></p>
<p>但是这种办法就不适用于class函数，因为class必须整体定义，不能切割。</p>
<p>而且这样写客户可以很轻松的拓展便利函数，他们只需要加入新的non-member non-friend函数到这个命名空间即可。</p>
<p>总结：<strong>若一个成员函数调用其他成员函数，那么这个成员函数的非成员函数版本比之拥有更多的封装性，和机能扩充性。</strong></p>
<h2 id="条款24：若所有参数皆需类型转换，请为此采用-non-member-函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用-non-member-函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用 non-member 函数"></a>条款24：若所有参数皆需类型转换，请为此采用 non-member 函数</h2><p>举例：有理数类和整数的运算</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>)<span class="comment">//分子与分母</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; right_number) <span class="type">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">onehalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result1 = onehalf * oneEighth;</span><br><span class="line">Rational result2 = onehalf * <span class="number">2</span>;</span><br><span class="line">Rational result3 = <span class="number">2</span> * onehalf;<span class="comment">//error!</span></span><br><span class="line"> </span><br><span class="line">onehalf*<span class="number">2</span> 相当于 onehaf.<span class="keyword">operator</span>*(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<p>首先创建了一个临时对象 const Rational temp(2);</p>
<p>再让两个 Rational 对象运算。</p>
<p>2<em>onehalf 是 2 调用了operator</em>。因为 2 是需要被转换的参数，而 2 的位置和 this（调用operator <em>） 对象的位置是一样的，所以无法将 2 转换成 Rational 类型，也就无法调用 operator</em> 函数。</p>
<p>解决办法：使用 non-member 函数，让左右参数的地位平等：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; left_number, <span class="type">const</span> Rational&amp; right_number)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>总结：如果所有参数（运算符左边或者右边的参数）都需要类型转换，用 non-member 函数。</strong></p>
<h1 id="没搞懂-条款25：考虑写一个不抛异常的-swap-函数"><a href="#没搞懂-条款25：考虑写一个不抛异常的-swap-函数" class="headerlink" title="没搞懂 条款25：考虑写一个不抛异常的 swap 函数"></a>没搞懂 条款25：考虑写一个不抛异常的 swap 函数</h1><p>周所周知，swap 可以交换两个数的值，标准库的 swap 函数是通过拷贝完成这种运算的。想想，如果是交换两个类对象的值，如果类中变量的个数很少，那么 swap 是有一定效率的，但如果变量个数很多呢？</p>
<p>你一定联想到了之前提过的，引用传递替换值传递。没错，交换两个类对象的地址就可以很有效率地完成大量变量的 swap 操作。不幸的是，标准库的 swap 并无交换对象地址的行为，所以我们需要自己写 swap 函数。</p>
<p>class person{…};</p>
<p>void my_swap(person&amp; p1, person&amp; p2)</p>
<p>{</p>
<p>​    swap(p1.ptr, p2.ptr);</p>
<p>}</p>
<p>这个函数无法通过编译，因为类变量是 private，无法通过对象访问。所以要把它变成成员函数。</p>
<p>class person</p>
<p>{</p>
<p>public:</p>
<p>​    void my_swap(person&amp; p)</p>
<p>​    {</p>
<p>​        swap(this-&gt;ptr, p.ptr);</p>
<p>​    }</p>
<p>​    …</p>
<p>};</p>
<p>如果你觉得 p1.my_swap(p2) 的调用形式太low了，你可以设计一个non-member 函数（如果是在同一个命名空间那就再好不过了），实现swap(p1, p2)，这里不做演示。你还可以特化 std 里的 swap 函数：</p>
<p>namespace std</p>
<p>{</p>
<p>​    template&lt;&gt;</p>
<p>​    void swap<person> (person&amp; p1, person&amp; p2)</person></p>
<p>​    {</p>
<p>​        p1.my_swap(p2);</p>
<p>​    }</p>
<p>}</p>
<p>值得注意的是，如果你设计的是类模板，而尝试对swap特化，那么会在 std 里发生重载，这是不允许的，因为用户可以特化 std 的模板，但不可以添加新的东西到 std 里。</p>
<p>还有一点：在上面工作全部完成后，如果想使用 swap ，请确定包含一个 using 声明式，一边让 std::swap 可见，然后直接使用 swap。</p>
<p>template<class t></class></p>
<p>void do_something(T&amp; a, T&amp; b)</p>
<p>{</p>
<p>​    using std::swap;</p>
<p>​    …</p>
<p>​    swap(a, b);</p>
<p>​    …</p>
<p>}</p>
<p> 其中过程：</p>
<p>如果T在其命名空间有专属的 swap，则调用，否则调用 std 的swap。</p>
<p>如果在 std 有特化的 swap，则调用，否则调用一般的 swap。（也即是拷贝）</p>
<p>\这一点虽然看着很奇怪……</p>
<p>总结：</p>
<p>1、当 std::swap 效率不高时，考虑自定义一个成员函数 swap</p>
<p>2、为成员函数提供非成员函数版本</p>
<p>3、类模板不要特化 swap，类特化 swap</p>
<p>\4、使用 swap 前要写 std::swap，以便在更多的语境下使用</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="条款26：尽可能延后定义式出现的时间"><a href="#条款26：尽可能延后定义式出现的时间" class="headerlink" title="条款26：尽可能延后定义式出现的时间"></a>条款26：尽可能延后定义式出现的时间</h2><p>当定义了一个变量，其类型带有构造函数和析构函数，那么<strong>即使这个变量未使用</strong>，当程序运行到这个变量定义式和离开作用域时，你就得承担构造成本和析构成本。例子如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">eeeeePassword</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="keyword">if</span>()&#123;....&#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码中，如果if句段有跳出函数的情况，那么就有可能a是完全没用，但是你却得承担构造和析构成本。</p>
<p>所以要尽可能延后定义式出现的时间，在需要用时在进行定义</p>
<h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>转型时，并不只是告诉编译器把某种类型视作另一种类型，而是会真的另编译器编译出运行期间执行的码，因为大部分计算器下，几乎所有<strong>不同的类型的底层表述都不一样</strong>。</p>
<p>应该要避免假设自己明白对象在底层是如何布局的，不应以此为基础进行转型操作，因为在不同平台下，他们的计算方式和布局方式不一定相同。</p>
<p>如果你想在子类中调用父类的函数，而这个函数已经在子类被override，就需要这么做：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Window::<span class="built_in">onResize</span>();</span><br></pre></td></tr></table></figure></div>

<p>不要写连串的dynamic_cast，</p>
<p>比如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（SpecialWindow *psw=<span class="built_in">dynamic_cast</span>&lt;...&gt;(....))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>（SpecialWindow *psw=<span class="built_in">dynamic_cast</span>&lt;...&gt;(....))</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>总结：</p>
<ol>
<li>如果可以，尽可能设计不要cast的代码。</li>
<li>如果必须要cast，那就尝试把他隐藏在某个函数中，不要客户主动使用转型。</li>
<li>宁可使用新的转型，而不是使用（int）aaa这样的旧转型，新转型更会被认出来。</li>
</ol>
<h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h2><p>看一下这个例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x,<span class="type">int</span> y);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span>&#123;</span><br><span class="line">    Point ulhc;</span><br><span class="line">    Point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::trl::shared_ptr&lt;RectData&gt; pData;<span class="comment">//单独写一个结构体来存放点的数据，会是对象小一点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;<span class="comment">//返回矩形的左上角</span></span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure></div>

<p>这样看的没啥问题，但是是自我矛盾的，一方面upperLeft函数是const，他的目的只是提供客户获取Rectangle相关坐标的方法，而不想让客户修改Rectangle，但是这个函数返回的又是reference，这样调用这就可以通过这个reference来修改内部数据了。</p>
<p>通过此我们明白：</p>
<ul>
<li>成员变量的<strong>封装性</strong>最多等于其“返回其reference”的函数的访问级别，比如前面例子中，ulhc是private，但是缺可以通过reference函数来访问修改。</li>
<li>如果const成员函数传出reference，后者的数据和对象有关联，但是又被储存在对象之外，那么函数的调用者就可以修改这个数据。！！！这个很重要，重点是<strong>虽然声明const但是还是可以修改数据。</strong></li>
</ul>
<p>reference、指针和迭代器都是所谓的handles（号码牌，用来获取某个对象），返回一个“代表内部数据”的handle，会<strong>有降低对象的封装性的风险</strong>，要注意！</p>
<h2 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h2><p>例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage= <span class="keyword">new</span> <span class="built_in">Image</span>(imSrc);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>“异常安全”的两个条件：</p>
<ol>
<li>不泄露任何资源。如果new Image导致异常，就不会unlock，就会导致一直锁着。</li>
<li>不允许数据败坏。如果new Image异常，bgImage就是指向一个已删除的对象，并且imageChanges的计数也是不对的。</li>
</ol>
<p>异常安全函数需满足：</p>
<ol>
<li><strong>基本保证</strong>：如果发生异常，程序内的任何事物仍然保持在有效状态下。</li>
<li><strong>强烈保证</strong>：保证发生异常时，程序状态不改变，比如说如果函数失败，程序回到“调用函数之前”的状态。</li>
<li><strong>不抛掷保证</strong>：保证绝不抛出异常，它们总能完成原先的承诺。</li>
</ol>
<p>我们的代码要满足上述三种保证之一。</p>
<p>资源泄露很好解决，如条款13、条款14的方法，使用对象或者智能指针来管理资源即可。</p>
<p>新写法：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在类中用shared_ptr储存bgImage，这样也不需要手动delete旧图像，他已经在智能指针内部处理了。</p>
<p>提供强烈保证的一种比较经典的方法：</p>
<p>这个策略被称作copy and swap：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span>&#123;</span><br><span class="line">    shared_ptr&lt;Image&gt; ngImage;</span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(pImpl,pNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>大概思路就是，搞个副本，全部弄清楚了在和原本需要修改的指针交换，c++11可以用move实现，效率更高。</p>
<p>这样就不会因为中途出现异常，导致修改了non-local的变量发生问题了。</p>
<p>但是“强烈保证”在现实中不一定具备意义，因为其会有降低性能等问题。</p>
<h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p>实际上他的性能优化比想象的多，因为编译器最优化机制通常被设计用来浓缩那些“不含函数调用”的代码，所以当你inline某个函数，他就会对此执行语句相关最优化。</p>
<p>但是他也有其缺点，因为inline的观念是，将“对此函数的每个调用”都以函数本体替换之。但是这会<strong>增加目标码（object code）的大小</strong>。</p>
<p>inline过多，会导致程序体积太大，即使有虚内存，inline造成的代码碰撞亦会导致额外的换页行为（paging），降低指令高速缓存装置的击中率（instruction cache hit rate），以及伴随这些而来的效率损失。</p>
<p><strong>但是如果inline函数本体小，编译器针对“函数本体”产生的码可能就比针对“函数调用”锁产生的码更小。</strong>这样就会有更棒的性能。</p>
<p>并且记住，inline只是对编译器的一个申请，不是强制指令。</p>
<p>一般来说，太复杂的函数，比如循环或者递归，会被拒绝，virtual函数也会被拒绝，因为virtual意味着<strong>等待，直到运行期结束才确定调用哪个函数</strong>，而inline意味着<strong>执行前，先将调用动作替换为调用函数的本体</strong>。而如果便能一起不知道要调用哪个函数，他就会拒绝。</p>
<p>inline的标准写法，要显式写出来：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">std::max</span><span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a&lt;b?b:a;&#125;</span><br></pre></td></tr></table></figure></div>

<p>番外：</p>
<p>c++对对象构建和销毁时发生了什么事情做了各种保证，他会在你的代码中填入一些“保证”来保证异常安全，例如，可能你的构造函数时空白的，但是他可能会在其中填入</p>
<p>try{….}</p>
<p>catch(…){</p>
<p>….;</p>
<p>throw;</p>
<p>}</p>
<p>等等。</p>
<p>除此之外，那些父类或者成员变量的构造函数也会被调用，这些都有可能被纳入到inline的替换考量中。</p>
<p><strong>程序库</strong>设计者必须评估“将函数声明为inline”的冲击：inline函数不好随着程序库的升级而升级，如果客户将一个inline函数f编入程序中，程序库设计者如果决定改变f，那所有用到f的客户端程序都必须<strong>重新编译</strong>。这是大家不愿见到的。</p>
<p>但是如果不是inline函数，客户端只需要重新连接即可，负担少很多，而且如果是采取动态连接，升级版函数甚至可以在不知不觉中就被应用程序吸纳。</p>
<p><strong>大多数调试器对inline函数都束手无策。</strong>毕竟你无法在一个并不存在的函数内设置断点。，大部分环境中仅仅智能“在调试版程序中禁止使用inlining”。</p>
<p>template和是否使用inline无关，这个要再看看书，不大懂这个。</p>
<h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><p>编译依存关系：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string theName;</span><br><span class="line">    Date thedate;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果修改了Person类中的某一实现，Person所包含的文件和任何使用Person的文件都要重新编译，，这问题就出在C++没有把“<strong>把接口从实现分离</strong>”做得很好。</p>
<p>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段式Handle classes 和Interface class。</p>
<p><strong>Handle classes：</strong></p>
<p>多用一层声明来包装Person，新建一个PersonImpl（Person Implementation），具体实现写在Impl中，Person的函数实现实际上是调用Impl的函数，这样修改实现时，是在修改Impl的函数，不会修改到Person也就不会引起重编译。</p>
<p>这个写法的重点是：</p>
<ul>
<li>尽可能使用object reference 和object pointers，而不是objects。你可以只靠一个类型<strong>声明式</strong>就定义出指向该类型的reference和points，但是如果是object，就需要该类型的<strong>定义式</strong>。</li>
<li>为声明式和定义式提供不同的头文件。？</li>
<li>如果可以，用class声明式而不是定义式。</li>
</ul>
<p><strong>Interface class：</strong></p>
<p>就是写个接口来和外界沟通，这样就不会具体涉及到实际调用的类，总感觉这个写法怪怪的。</p>
<p>但是这二者都会消耗性能，需要做权衡。</p>
<h1 id="继承与面对对象设计"><a href="#继承与面对对象设计" class="headerlink" title="继承与面对对象设计"></a>继承与面对对象设计</h1><h2 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h2><p>is-a关系：是一个…，例如student继承自person，那student是一个person，就是这个意思，要保证子类一定在父类中，形成包含关系。</p>
<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p>子类的名称会遮掩base classes内的名称，但是public的继承下没人会希望这样，解决方法：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果不写using那行，mf1()函数就会遮掩住基类的这个函数，就无法在子类中调用mf1(int)的这个形式。</p>
<p>但如果你只要继承那个无参数版本，可以这么写：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base::<span class="built_in">mf1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><p>作为设计者，有时候你会希望derived classes 只继承成员函数的接口（也就是声明）；而有时候你又希望derived classes 同时继承函数的接口和实现，但又希望能够覆写他们所继承的实现；…</p>
<ul>
<li>声明一个pure virtual的目的是为了让derived classes 只继承函数接口。</li>
<li>声明impure virtual函数的目的，是让derived classes继承该函数的接口和<strong>缺省实现</strong>。</li>
</ul>
<p>看眼书把，描述太麻烦了。。。</p>
<ul>
<li>声明non-virtual函数的目的是为了令derived classes继承函数的接口和一份<strong>强制性实现</strong>。 其代表的意义是不变性凌驾于特异性之上，所以他不应该在子类中被重新定义。</li>
</ul>
<h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><p>认证考虑virtual函数意外的其他替代方案，跳脱出面对对象设计路上的常轨：</p>
<p>常规写法：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//返回角色的健康指数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>藉由Non-Virtual Interface实现Template Method 模式</li>
</ol>
<p>这个流派认为，<strong>virtual函数应该几乎都是private的</strong>，所以建议保留healthValue为public成员函数，让他为non-virtual，然后调用一个private virtual函数来进行实际操作：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span><span class="comment">//返回角色的健康指数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...<span class="comment">//事前工作</span></span><br><span class="line">        <span class="type">int</span> retVal=<span class="built_in">doHealthValue</span>();</span><br><span class="line">        ...<span class="comment">//事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个设计是令客户通过public non-virtual成员函数间接调用private virtual函数，也就是在具体实现的函数又包了一层，然后可以在这一层处理一下事前事后的状态。</p>
<ol>
<li>藉由Function Pointers实现Strategy模式</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHeatlhCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HeatlhCalcFunc)</span> <span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">    : healthFuc(hcf)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个写法是常见的Strategy设计模式的简单应用，他提供了某些特殊的弹性：</p>
<ul>
<li>同一个人物类型可以拥有多个不同的健康计算函数</li>
<li>某已知的人物的健康计算函数可以在运行期变更。</li>
</ul>
<p>但是这个方法的问题是这个函数指针只能调用人物类的public接口来计算，如果涉及到private信息就会比较尴尬（解决办法是弱化class的封装，或者在类内部写一个public函数总结private的变量），所以就需要去平衡优点与缺点。</p>
<ol>
<li>藉由tr1::function完成Strategy模式 C++STL的拓展（TODO::…..)</li>
<li>古典的Strategy模式：</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="/Read-Effective-C.assets/asynccode" alt="img"></p>
<p>代码如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;.... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">    : pHealthFuc(phcf)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> pHealthFunc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc pHealthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>感觉这个就是用一个类把生命计算函数包起来了。</p>
<h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p>如果你这么做了就会：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B* pB=&amp;x;</span><br><span class="line">D* pD=&amp;x;</span><br><span class="line">pB-&gt;<span class="built_in">func</span>();</span><br><span class="line">pD-&gt;<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></div>

<p>此时调用的函数就会不一样，因为non-virtual函数的静态绑定的，是根据声明来选择调用哪个函数的，而virtual是动态绑定，会根据实际的类类型来选择调用。</p>
<p>其他部分主要是在强调前面的条款，比如条款32、条款7等。</p>
<h2 id="条款37：绝不重新定义继承来的缺省参数值"><a href="#条款37：绝不重新定义继承来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承来的缺省参数值"></a>条款37：绝不重新定义继承来的缺省参数值</h2><p>重提动态绑定和静态绑定：</p>
<p>静态绑定是他在程序中被声明时所采用的类型，而动态绑定是指“目前所指对象的类型”。</p>
<p>virtual函数的动态绑定的，而缺省参数值缺省静态绑定的。</p>
<p>试例如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong></p>
<p>如果是写作Circle的这种少去缺省值的写法，在客户以<strong>对象</strong>调用此函数时，一定要指定参数值。因为静态绑定下这个函数不会从base继承缺省参数值，</p>
<p>但是如果是以<strong>指针或者引用</strong>调用该函数则可以不指定参数值，因为动态绑定下这个函数会从base继承缺省参数值。</p>
<p>但是如果是Rectangle类，缺省调用时也会有类似的问题，以对象调用此函数时会以静态绑定的对象的缺省为准，而用指针或者引用时缺省则是Red。</p>
<p>但是如果你修改成缺省值一样的也会很奇怪，代码重复，又带有相依性，当你修改base类的缺省值，derived calsses也得进行修改，很麻烦，比较好的办法是如条款35中的，virtual函数的代替设计，如non-virtual Interface。多包装一层。</p>
<h2 id="条款38：通过复合塑膜出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑膜出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑膜出has-a或“根据某物实现出”"></a>条款38：通过复合塑膜出has-a或“根据某物实现出”</h2><p>复合的意义与public继承完全不同，复合是has-a的关系，是我这个东西有一个什么什么样的东西&#x2F;功能。</p>
<p>而在实现域，复合意味着根据某物来实现，比如根据list来实现set。</p>
<h2 id="条款39：谨慎地使用private继承"><a href="#条款39：谨慎地使用private继承" class="headerlink" title="条款39：谨慎地使用private继承"></a>条款39：谨慎地使用private继承</h2><p>如果是private继承，</p>
<ol>
<li>编译器不会自动将一个derived class对象转换为base class对象</li>
<li>由private base class继承而来的所有成员，在derived class中都会变成private属性，即使他们在base class中原本是public或者protected。</li>
</ol>
<p>private继承意味着“根据某物实现出”。</p>
<p>他的写法一般是：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用private继承，将onTick函数变成private，防止客户调用他，但是这么设计也并非必要，比如说我们可以用复合的手法来实现这个效果，在Widget内放一个Timer的对象即可，</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>如果Widget继承自Timer</strong>并且你想写一个Widget的派生类，它就不得不重新定义onTick，但是这实际上是没意义的，但是如果说WidgetTimer是Widget内部的一个private成员并继承Timer（<strong>也就是上面的写法</strong>），Widget的派生类就无法取用WidgetTimer，因此无法继承或重定义它的virtual函数。这就是一种<strong>阻止派生类重新定义virtual函数的写法</strong>。</p>
<p>这样的写法还可以将Widget的编译依存性降到最低，在内部定义，就不用再include别的头文件了。</p>
<p>private其实是一种很激进的写法，它可以达到空间最优化。</p>
<p>C++裁定，任何独立的对象都必须由非零的大小，所以：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这样的写法，HoldsAnInt类会有两个int的大小，他会往empty类塞一个char大小的内存，然后因为内存对齐的问题再塞一个垫子。</p>
<p>但是如果是private就不会，因为private<strong>并非是独立</strong>的。</p>
<p>但是一般来说，还是会选择复合，因为复合更容易理解，但是如果，当你面对“并不存在is-a关系”的两个classes，其中一个需要访问另一个protected成员，或者需要重新定义其一或多个virtual函数是，private继承可能会是正确的设计思路。</p>
<p><strong>总结：</strong></p>
<p>当你面对“并不存在is-a关系”的两个classes，其中一个需要访问另一个protected成员，或者需要重新定义其一或多个virtual函数是，private继承可能会是正确的设计思路。</p>
<p>private可以实现empty base最优化，追求极致的内存的话，这很重要。</p>
<h2 id="条款40：谨慎地使用多重继承"><a href="#条款40：谨慎地使用多重继承" class="headerlink" title="条款40：谨慎地使用多重继承"></a>条款40：谨慎地使用多重继承</h2><p>多重继承下，可能继承的两个对象会有相同的函数名，</p>
<p>需要这样去除歧义：mp.Item::checkOut();</p>
<p><strong>钻石继承的问题：</strong></p>
<p>但你使用钻石继承时，就会面对这样的问题：</p>
<p><strong>是否打算让base class内的成员变量经由每一条路径被复制？</strong></p>
<p><strong>假设基类中有个成员变量fileName，那最后的派生类中又该有多少笔这个名称的数据呢？</strong></p>
<p>也就是说，在派生类中应该又几个fileName，C++在其中并没有倾斜的立场，虽然它缺省做法时执行复制，也就是有两个fileName，如果你不想如此，你可以让那个带有该数据的class成为virtual base class。这样做的话你必须让<strong>所有直接</strong>继承自它的classes采用virtual继承。</p>
<p><strong>virtual继承的代价：</strong></p>
<ul>
<li>classes若派生自virtual base而需要初始化，必须认知其virtual base，不管那些base有多远。</li>
<li>当一个新的派生类加入继承体系中，他必须承担virtual bases的初始化责任。</li>
</ul>
<p>也就是说，virtual base的初始化责任是由继承体系的最远派生类负责的。</p>
<p>按正确性的观点来看，public继承应该总是virtual的，但是正确的并不一定是合适的，因为virtual继承会有更多的消耗，代价大，对其的<strong>忠告</strong>是：</p>
<p>非必要不使用virtual class，如果你一定要使用virtual class，尽可能避免不在其中放数据，这样就不要担心这些class上出现的初始化或赋值带来的诡异事情了。 </p>
<p>多重继承的科学使用方法：</p>
<p>CPerson必须实现IPerson接口，由需要PersonInfo的virtual函数来实现功能。</p>
<p>这样CPerson就可以public继承IPerson，private继承PersonInfo了。</p>
<h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><p>面对对象总是以显式接口和运行期多态来解决问题。显示接口也就是说<strong>这个接口（类）在源码中明确可见</strong>，而运行期多态是说，virtual的成员函数，类对其的调用都是<strong>根据运行期的动态类型类决定调用哪个函数的</strong>。</p>
<p>而模板和泛型编程的事件与其有着根本性的不同：</p>
<p>看个例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; W)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>()&gt;<span class="number">10</span>&amp;&amp;w!=someNastyWidget)&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>W必须支持哪些接口呢？这由template中，对于W执行的操作来决定。就本例而言，W需要支持size，swap成员函数和copy构造函数等等等。</li>
<li>凡是涉及w的任何函数调用，例如operator&gt;和operator !&#x3D;，都有可能造成template实例化（？），使这些调用成功。实例化的过程发生在编译期。</li>
</ul>
<p>template实例化指函数模板（类模板）生成模板函数（模板类）的过程</p>
<p><strong>运行期多态“哪个virtual函数应该被绑定”，编译期多态“哪个重载函数应该被调用”。</strong></p>
<p>显式接口时由函数签名式构成，也就是函数名称、参数类型、返回类型这些。</p>
<p>而隐式接口是由有效表达式构成的。</p>
<p>看上面的例子，T的隐式接口似乎必须提供一个size的成员函数，返回一个整数值；以及必须支持operate！&#x3D;函数用来比较对象。</p>
<p>但是由于操作符重载的效果，这两个约束都不用满足了，可以通过各种各样的隐式转换能得到需要的类型即可。</p>
<p>但是其他的哪些无法通过隐式转换来满足的接口，如“copy构造函数”等就必须要有效。</p>
<p><strong>这些隐式接口，和class对象上的显式接口一样，都在编译期完成检查。</strong></p>
<h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p>template<class t> class Widget;</class></p>
<p>template<typename t> class Widget;</typename></p>
<p>这两者没有不同，<strong>效果是完全一样的</strong>，有些人喜欢class，有些人喜欢写typename，作者比较推荐typename，因为typename可以暗示参数并非一定得是class类型。</p>
<p>typename有个比较重要的一般性用法：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">it</span><span class="params">(container.begin())</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>这句如果没有typename会报错，因为C++会假设C::const_iterator不是个类型，加个typename声明其是个类型。</p>
<p>所以，<strong>一般性的规则</strong>是：任何时候当你想要在template中指涉一个<strong>嵌套从属类型名称</strong>，就必须在紧邻它的前一个位置放上typename。并且，typename仅仅用来验明<strong>嵌套从属类型名称</strong>，其他名称不要写他。</p>
<p>这个规则的例外是，不可以出现在base classes list内的嵌套从属名称之前，也不可在成员初值列中作为base class修饰符。如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&lt;T&gt;:Nested&#123;<span class="comment">//不要加typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p>例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对此模板类，我们想要以此为基类做拓展类：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> ...:<span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="built_in">sendClear</span>(info);</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样的代码会无法通过编译，因为编译器知道<strong>base class templates 可能被特化</strong>，但是特化版本可能不提供一般性template相同的接口，所以往往拒绝在templatized base classes内寻找继承而来的名称。</p>
<p>解决办法：</p>
<ul>
<li>在base class函数调用前，加上this-&gt;:</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> ...:<span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用using声明式。类似于条款33的做法，但是这里的作用和条款33不同，这里的作用是请<strong>编译器进入base class作用域进行查找函数</strong>，而条款33的作用是<strong>防止derived class名称被derived class名称遮掩</strong>。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> ...:<span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="built_in">sendClear</span>(info);</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>让其指出调用函数在base class内：</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> ...:<span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个是最不让人满意的做法，因为如果调用的是virtual函数，上述的明确修饰会<strong>关闭virtual绑定行为</strong>。</p>
<p>但是如果你的基类是特化的并且没有这个函数，那还是会报错的。</p>
<h2 id="条款44：将与参数无关的代码抽离template（本节内容不止如此，看原文）"><a href="#条款44：将与参数无关的代码抽离template（本节内容不止如此，看原文）" class="headerlink" title="条款44：将与参数无关的代码抽离template（本节内容不止如此，看原文）"></a>条款44：将与参数无关的代码抽离template（本节内容不止如此，看原文）</h2><p>模板类是可以这么写的：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时如下：</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>,<span class="number">10</span>&gt; sm1;</span><br></pre></td></tr></table></figure></div>

<p>template前面为类型参数T，后面为非类型参数，这样的写法会造成代码膨胀，导致代码中会有很多重复的部分，比如说实例化两份invert函数，他们几乎完全相同，只是操作的矩阵大小不同，比较好的写法是把这个函数提出来，提成什么都可以，比如基类，或者是把模板定义的n放到函数里面去。</p>
<p>参数函数也会造成代码膨胀，比如许多平台上int和long有相同的二进制表述，想vector<int> 和vector<long>的成员函数可能完全一样，最佳的写法是使得template持有指针者，对每个成员函数使用唯一一份底层实现，也就是说，如果你<strong>实现某些成员函数</strong>而他们操作T*，你应该令它<strong>调用void*的函数</strong>，由此函数完成实际工作。</long></int></p>
<h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>普通指针比较好的一点是，它支持隐式转换，派生类指针可以转化为基类指针，但是智能指针不大行。</p>
<p>同时，template的不同实例之间没有什么固有关系，没有继承关系，后续讲讲如果实现模板类之间的转换。</p>
<p><strong>Template和泛型编程</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后我们希望实现：</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt1=<span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br></pre></td></tr></table></figure></div>

<p>我们希望实现这样的转化效果，但是如果我们正常写的话，就需要写无限多个构造函数，不现实，所以我们需要写一个构造模板，为class生成函数：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>大概这样的形式，可以根据对象U来创建一个对象T，称其为泛化copy构造函数。</p>
<p>但是同时我们又希望可以只向上转换，比如说top不能转换成bottom，但是bottom能转换成top这样。</p>
<p>所以现在我们的写法是这样的：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span></span></span><br><span class="line"><span class="function">    : heldPtr(other.get()) &#123;</span>...&#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>获取U<em>的指针作为初值，放在成员初值列来初始化T。这样就只有当存在隐式转换可以将一个U</em>指针转为一个T*指针的时候才能通过编译。</p>
<p>但是成员函数模板并不会改变语言规则，比如说前面我们设计了一个泛化copy构造函数模板，但是编译器还是会为我们生成一个默认的构造函数，所以如果我们要<strong>阻止这个行为</strong>，我们就需要同时声明<strong>泛化copy构造函数</strong>和<strong>正常的构造函数</strong>。</p>
<h2 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h2><p>现在我们来讨论template的实参推导。</p>
<p>按照条款24的说法，如果我们要实现operator*的混合式调用，可以这么写：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>)<span class="comment">//分子与分母</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    </span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; right_number,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; left_number) <span class="type">const</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Rational&lt;T&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>但是对于模板类，这样会报错，因为编译器只知道我们要调用operator*这个函数，但是不知道具体要调用哪个实例函数，也就是说T不能确定。（这里我讲的比较模糊，建议看看原文比较完整的说明，或者看完解决方法也有助于理解）</p>
<p><strong>隐式类型转换</strong>会在函数调用过程中被使用，但在调用一个函数前，必须知道这个函数的存在，所以必须先为<strong>相关的模板函数</strong>推导出需要的参数类型，这样才能<strong>实例化</strong>这个模板函数。</p>
<p>但是对于template的实参推导并不会采取“通过构造函数而发生的”隐式类型转换。</p>
<p>解决方法：</p>
<p>将这个operator*纳入模板类作为friend函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>)<span class="comment">//分子与分母</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; right_number,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; left_number);<span class="comment">//声明</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    </span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; right_number,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; left_number);<span class="comment">//实现</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational&lt;T&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>这么写对operator<em>的混合调用就可以通过编译了，因为对象oneHalf声明为Rantional<int>时，friend函数operator</int></em>也<strong>被自动声明出来</strong>，就已经有了这样一个函数，并且<strong>其为函数而非函数模板</strong>，然后再调用时编译器就知道时需要调用这个函数，然后就可以进行隐式转换了。</p>
<p>但是现在可以编译但是无法连接。？？？？</p>
<p><strong>能通过编译是因为</strong>：编译器知道了我们要调用哪个函数，</p>
<p><strong>不能连接是因为</strong>：那个函数只在Rational内被声明，而没有被定义出来，无法让在class外部的operator* template提供定义式。连接器找不到定义式，所以不能连接。</p>
<p>解决办法很简单，既然无法让在class外部的operator* template提供定义式，那就写在class内部即可：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>)<span class="comment">//分子与分母</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; right_number,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; left_number);<span class="comment">//声明</span></span><br><span class="line">    &#123;...&#125;<span class="comment">//实现</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Rational&lt;T&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>虽然看起来很奇怪，但是很科学：</p>
<p>我们虽然用了friend关键字，但是却和friend的正常用法“访问class的non-public成分”没有关系。</p>
<p><strong>逻辑思路</strong>是这样的：我们需要让不同类型转换发生在所有实参上，所有我们需要一个non-member函数，为了让这个函数具现化，所以需要声明在class内部，而声明在内部的唯一方法就是让他成为friend函数。并且这样还可以在内部定义它。</p>
<p>所以这里friend的效果就很神奇，这个函数实际上是在class外部的，但是它可以和class一起实例化。</p>
<p>除此之外，如条款30所说，定义在class内部的函数都暗自成为inline。可以托管令operator<em>只调用一个class外的辅助函数，这样使得inline的冲击最小化。但是对于本例子没啥用，因为本例中的operator</em>就只有一行，如果时更复杂的函数就有价值。</p>
<h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h2><p>traits是一种技术，目的是<strong>提取</strong>传入对象对应的返回类型，让同一接口实现对应的功能，并且大部分性能是在编译期实现的，效果好。</p>
<p>实现方案是这样的：</p>
<ul>
<li>建立一组重载函数，或实际执行的函数模板，差异只在于传入的traits变量。</li>
<li>建立一个控制函数或者函数模板，在控制函数中调用上述重载函数传入traits进行控制。</li>
</ul>
<p>区分传入变量的方法一般是<strong>写一个type枚举，然后放入自定义类中</strong>，而对于系统自带的类型，比如int，就需要另一种实现方法，也就是<strong>用一个模板类包着</strong>，然后在模板类中表示其在traits中的类型。</p>
<h2 id="条款48：认识template-元编程"><a href="#条款48：认识template-元编程" class="headerlink" title="条款48：认识template 元编程"></a>条款48：认识template 元编程</h2><p>模板元编程是以c++写成、执行与c++编译器内的程序，一旦TMP程序执行结束，其输出，也就是从模板具现出来的c++源码，都会正常的被编译。</p>
<p>TMP可以将工作从运行期转移到编译期，这导致某些错误原本应该在运行期才能检测到，但是现在可以在编译期找出来。并且会更高效：更小的执行文件、更短的运行期、更小的内存需求。而代价是编译时间变长了。</p>
<p>TMP现在已经足以计算任何事物，可以用其声明变量、执行循环、编写和调用函数，比如上一条款中的，就是使用TMP实现了if..else语句。</p>
<p>现在我们来介绍一下TMP是如何执行循环的。</p>
<p>这个循环不涉及递归函数调用，而是涉及“递归模板实例化”。</p>
<p>TMP的hello world是在编译期计算阶乘：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;value=<span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>循环发生在template实例化Factorial<n>时，内部声明下一个Factorial<n-1> ，就是这样进行递归调用，然后在特殊情况，也就是n&#x3D;0时结束。</n-1></n></p>
<p>TMP可以实现的效果：</p>
<ol>
<li>确保度量单位正确。用TMP可以在编译期确保单位组合正确。</li>
<li>优化矩阵计算。expression templates</li>
<li>实现客户定制的设计模式，比如在编译期间生产一大堆智能指针类型。</li>
</ol>
<h1 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h1><h2 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h2><p>在operator new抛出异常前，会先调用客户指定的错误处理函数，一个new-handler。</p>
<p>new-handler是长这样的：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handle)</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>new_handler定义出一个指针指向函数，这个函数没有参数也不返回任何东西。set_new_handler时获得一个new_handler并返回一个new_handler的函数。</p>
<p>set_new_handler的参数是<strong>一个指针</strong>，指向operator new无法分配足够内存时<strong>该被调用的函数</strong>，返回值也是一个指针，指向set_new_handler调用前<strong>正在执行的那个new_handler函数</strong>。</p>
<p><strong>用法：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfNem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cerr  &lt;&lt; <span class="string">&quot;Unable to.....&quot;</span>;</span><br><span class="line">    std:: <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set_new_handler（outOfMem）;</span><br><span class="line">    <span class="type">int</span>* p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000000000000000000</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>本例中，会因无法分配这么大的空间调用outOfMem。</p>
<p>Operator new 无法满足内存申请时，会不断调用new-handler函数，直到找到足够内存。</p>
<p>设计良好的new-handler应该做到以下部分能力：</p>
<ul>
<li><strong>让更多内存被使用。</strong>实现这个策略的一种做法是，程序一开始就分配一大块内存，而后在new-handler调用时，将其还给程序使用。</li>
<li><strong>安装另一个new-handler。</strong>如果目前这个new-handler无法取得更多可用内存，然他知道另一个new-handler有此能力，然后set另一个new-handler，以便下次使用。</li>
<li>卸除new-handler。将null传给set_new-handler。</li>
<li>抛出bad_alloc的异常。这样异常就不会被operator new捕捉，因此会被传播到<strong>内存索取处</strong>。</li>
<li>不返回。</li>
</ul>
<p>有时候你希望以不同的方式处理内存分配失败的情况，你希望视被分配物属于哪个class 而定，但是c++并不支持class专属new-handler这种行为，但是我们可以自己实现这种行为：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std:<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>并且，static成员需要在class定义式之外被定义：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::new_handler Widget::currentHandler = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>然后<strong>Widget内的set_new_handler函数会将它获得的指针存储起来，然后返回先前存储的指针，</strong>这也是标准版set_new_handler的作为。</p>
<p><img lazyload src="/images/loading.svg" data-src="https://z1wt6ruhl99.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFjYjkyOWU0MTYxMjhkY2VlYjViOGY4MjMyZWU1MjNfYjhvZ3BXVmk0NEpyQkxZWGVUc3hXbUt3cElHVlhpTm1fVG9rZW46SDVWWGJ0YUVFb3hwTHJ4SmFKTmNUeDlJbk9nXzE3NTIxOTUzNTk6MTc1MjE5ODk1OV9WNA" alt="img"></p>
<p>并且这套效果可以做成一个模板来实现，</p>
<p><img lazyload src="/images/loading.svg" data-src="/Read-Effective-C.assets/asynccode" alt="img"></p>
<p>其中这个模板类中，并没没有用到T，这里这个模板只是为了让每个类都有自己的实例new_handler，不然其起冲突。</p>
<p>但是还是很奇怪，我们实际使用的时候就会写出：</p>
<p>Widget继承了NewHandlerSupport<Widget>这样的情况，但是实际上没事，是合法的。</Widget></p>
<h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><p><strong>为什么要替换new和delete？</strong></p>
<ul>
<li><strong>用来检测运用上的错误</strong>。比如说可以定义一个operator news，用来超额分配内存，用额外的空间放置签名，然后deletes可以检查签名是否完好，如果否就表示发生了overrun或者underrun，这样就可以log出这个情况和惹是生非的指针了。</li>
<li><strong>强化性能</strong>。因为缺省的new和delete用于一般目的，对所有情况的性能都比较平均，但如果我们清楚的知道自己程序的动态内存运用型态，就写出适合自己的new和delete，以此来提升性能表现。包括<strong>减小空间的额外开销</strong>。</li>
<li><strong>收集使用上的统计数据</strong>。比如分配区块的大小分布如何？寿命分布如何？等等</li>
<li>为了你不缺省分配器中的非最佳齐位。</li>
<li>为了将相关对象成簇集中。主要是为了防止内存页错误。</li>
</ul>
<h2 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h2><p>Operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果无法满足就调用new-handler。并且其有能力处理0bytes申请，class的专属版本还需加上一个处理“比正确大小更大的错误申请”。</p>
<p>Operator delete 应该在收到null指针时不做任何事情，class的专属版本还需加上一个处理“比正确大小更大的错误申请”。</p>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Read Effective C++</li>
        <li><strong>Author:</strong> 沐云白</li>
        <li><strong>Created at
                :</strong> 2025-03-12 17:55:44</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-07-11 08:56:32
            </li>
        
        <li>
            <strong>Link:</strong> https://redefine.ohevan.com/2025/03/12/Read-Effective-C/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2025/04/11/My-Little-GAS/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">自制简易GAS</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2025/02/07/ModularGameplay-Learn/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">ModularGamePlay相关理解</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">Read Effective C++</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="nav-text">自己习惯C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E6%8A%8A-C-%E7%9C%8B%E6%88%90%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="nav-text">条款01：把 C++ 看成一个语言联邦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E7%94%A8const-enum-inline-%E6%9B%BF%E6%8D%A2-define"><span class="nav-text">条款02：用const, enum, inline 替换 #define</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-const"><span class="nav-text">条款03：尽可能使用 const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">条款04：确定对象被使用前已经被初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%EF%BC%8C%E6%9E%90%E6%9E%84%EF%BC%8C%E8%B5%8B%E5%80%BC"><span class="nav-text">构造，析构，赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-text">条款05：了解C++默默编写并调用哪些函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="nav-text">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E7%BB%99%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E-virtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">条款07：给多态基类声明 virtual 析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">条款08：别让异常逃离析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">条款09：绝不在构造和析构函数中使用虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4-operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="nav-text">条款10：令 operator&#x3D; 返回一个 reference to *this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8-operator-%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC"><span class="nav-text">条款11：在 operator&#x3D; 中处理自我赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="nav-text">条款12：复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-text">条款13：以对象管理资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83-copying-%E8%A1%8C%E4%B8%BA"><span class="nav-text">条款14：在资源管理类中小心 copying 行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">条款15：在资源管理类中提供对原始资源的访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8-new-%E5%92%8C-delete-%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="nav-text">条款16：成对使用 new 和 delete 时要采取相同形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-newed-%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">条款17：以独立语句将 newed 对象置入智能指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="nav-text">设计与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="nav-text">条款18：让接口容易被正确使用，不易被误用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1-class-%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1-type"><span class="nav-text">条款19：设计 class 犹如设计 type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5-pass-by-reference-to-const-%E6%9B%BF%E6%8D%A2-pass-by-value"><span class="nav-text">条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6-reference"><span class="nav-text">条款21：必须返回对象时，别妄想返回其 reference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA-private"><span class="nav-text">条款22：将成员变量声明为 private</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5-non-member-non-friend-%E6%9B%BF%E6%8D%A2-member-%E5%87%BD%E6%95%B0"><span class="nav-text">条款23：宁以 non-member, non-friend 替换 member 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8-non-member-%E5%87%BD%E6%95%B0"><span class="nav-text">条款24：若所有参数皆需类型转换，请为此采用 non-member 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B2%A1%E6%90%9E%E6%87%82-%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84-swap-%E5%87%BD%E6%95%B0"><span class="nav-text">没搞懂 条款25：考虑写一个不抛异常的 swap 函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%AE%9A%E4%B9%89%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-text">条款26：尽可能延后定义式出现的时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="nav-text">条款27：尽量少做转型动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="nav-text">条款28：避免返回handles指向对象内部成分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="nav-text">条款29：为“异常安全”而努力是值得的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="nav-text">条款30：透彻了解inlining的里里外外</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="nav-text">条款31：将文件间的编译依存关系降至最低</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="nav-text">继承与面对对象设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB"><span class="nav-text">条款32：确定你的public继承塑模出is-a关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-text">条款33：避免遮掩继承而来的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-text">条款34：区分接口继承和实现继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="nav-text">条款35：考虑virtual函数以外的其他选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="nav-text">条款36：绝不重新定义继承而来的non-virtual函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-text">条款37：绝不重新定义继承来的缺省参数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E8%86%9C%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="nav-text">条款38：通过复合塑膜出has-a或“根据某物实现出”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE39%EF%BC%9A%E8%B0%A8%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF"><span class="nav-text">条款39：谨慎地使用private继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE40%EF%BC%9A%E8%B0%A8%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text">条款40：谨慎地使用多重继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="nav-text">条款41：了解隐式接口和编译期多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="nav-text">条款42：了解typename的双重意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-text">条款43：学习处理模板化基类内的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplate%EF%BC%88%E6%9C%AC%E8%8A%82%E5%86%85%E5%AE%B9%E4%B8%8D%E6%AD%A2%E5%A6%82%E6%AD%A4%EF%BC%8C%E7%9C%8B%E5%8E%9F%E6%96%87%EF%BC%89"><span class="nav-text">条款44：将与参数无关的代码抽离template（本节内容不止如此，看原文）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE45%EF%BC%9A%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="nav-text">条款45：运用成员函数模板接受所有兼容类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE46%EF%BC%9A%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">条款46：需要类型转换时请为模板定义非成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-text">条款47：请使用traits classes表现类型信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE48%EF%BC%9A%E8%AE%A4%E8%AF%86template-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-text">条款48：认识template 元编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete"><span class="nav-text">定制new和delete</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE49%EF%BC%9A%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-text">条款49：了解new-handler的行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE50%EF%BC%9A%E4%BA%86%E8%A7%A3new%E5%92%8Cdelete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="nav-text">条款50：了解new和delete的合理替换时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE51%EF%BC%9A%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="nav-text">条款51：编写new和delete时需固守常规</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">沐云白</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        14 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.7.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>








    
<script src="/js/libs/anime.min.js"></script>





    
<script src="/js/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/layouts/essays.js" type="module" data-swup-reload-script=""></script>




</body>
</html>
